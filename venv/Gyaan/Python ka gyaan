 ðŸ˜ƒPython 3.0

 ðŸ˜ƒ comments: # is used to comment

 Data types:
 ðŸ˜ƒtype(value_of_variable) => gives data type of variable
 ðŸ˜ƒ/ -> devision
     rounding: ðŸ˜ƒround(number, decimal_points)
 ðŸ˜ƒ// -> integer devision (10 // 3 = 3 , not 3.33.. ) ;
 ðŸ˜ƒ exponentiation : 2 ** 3 = 8

 multiple variable assignment: a,b,c = 1,2,3 => a=1, b=2, c=3

 in python:
   list is array[]
   dictionary is map<k,v>

  String can be in single or double quotes, doesnt make a difference
  String formatting (f "{variable}") : => f is mandatory to format
  cnt = 2 ; print(f"count is ðŸ˜ƒ{cnt}")

  String index: name = divya
  print(name[0]) => d ; print(name[-1]) => a ; ðŸ˜ƒ-ve indexes start from end of string

  ðŸ˜ƒdata type conversion: * 'str' is a reserved keyword *
  age_list = [10,11,12]
  age_string = str(age) ; print(  age_string ) => "10,11,12"

  ðŸ˜ƒ read from user/console :
  value = ðŸ˜ƒinput()  or input("prompt message")  => input is always in string , need to convert it precise data type


  ðŸ˜ƒConditional blocks:
  if condition:
    do..
  elif condition:
    do..elif...
  else:
    do..else..

  x is 1 # true if x = 1 else false

  a = [1,2,3]
  b = [1,2,3]
  a == b => true
  ðŸ˜ƒa is b => false ? not in same place in memory


  LOOPING:

  for item in iterable_object:
    do.. . .

  while boolean_condition:
    do...


Lists:
lis_items = [a,b,c,d]
len(lis_items) => 4

tasks = list(range(1,10))
tasks.sort()
tasks.append(11) => 11 items
tasks.append([12,13]) => 12 items in total, this array is added as a single member
    .clear() , .remove("item_value")
    .index(item_value) => index of this value
    .index(item_value, start_from_index_value) => index of this value
    .index(item_value, start_from_index_value, end_index_value)
    .count(value) => gives count of item
    .reverse()
 join(tasks) => '1 2 3 . . n'
 tasks[start:end:step] => for slicing the list (-ve no. start from end)
 tasks = [a,b,c,d]
 tasks[1:] => b,c,d
 tasks[1:3] => b,c
 tasks[1::2] => b,d
 swapping => tasks[x], tasks[y] = tasks[y], tasks[x]

 List comprehension:
 task = [1,2,3,4]
 [operation for var in list_var condition]
 [x*2 for x in task if x%2 == 0] => [4,8]


 Dictionaries:
 myDict = {'key': 'value'} OR {'key' = 'value'}

 print(myDict['key']) => value

 iteration:
 for val in myDict.values():
    do...

 for k,v in myDict.items():
    print(k + v) . . . .

    'key' in myDict => gives true/false as per presence

Methods in dictionary:
    myDict = {'a': 1, 'b': 2}
    x = myDict.copy()
    => x == myDict => true
        x is myDict => false as different references

   ðŸ˜ƒfromKeys()

   {}.fromKeys('a', 'b') #{'a', 'b'}
   {}.fromKeys([a,b], 1) # {'a':1, 'b': 1} => usage ? default value assignment
   {}.fromKeys('a', [1,2,4]) #{'a', [1,2,4]}

   myDict.get('key') => either value or none if not present

   ðŸ˜ƒ.pop('key') => removes and get item
   ðŸ˜ƒ.popitem() => removes random item

   tempDict = ðŸ˜ƒdict('x': 1, 'y': 2)
   myDict.ðŸ˜ƒupdate(tempDict) => {'a': 1, 'b': 2, 'x': 1, 'y': 2}

Dictionary comprehension:
  [key_opr: val_opr for var in dictVar condition]
  [key*1 : val + 1 for key,val in myDict if key %2 == 0]

Tuples:
    immutable, faster than lists
    myTpl = (1,2,3,4) or tuple(1,2,3,4)

    we cant use List as key but can use tuple as a key as keys shouldn't change! ???

    location = { (76.12, 21.324) : 'tokyo'} => ok
    location = { [76.12, 21.324] : 'tokyo'} => error, non hashable types

    myTpl.index(item) => index or error if not present

    nested tuples  => (1,2,(3,4,5),6) => ok

ðŸ˜ƒSets:
    no duplicates, unordered
    x = {1,2,3,1,2,4}
    y = set(x) => {1,2,3,4}
    or z = set(1,2,3,4,1) => {1,2,3,4}

  ðŸ˜ƒMethods in Set:
  x.add(value) => duplicate ? no error, just not added!
  x.remove(value) => removes or error if not present
    .clear()
    intersection => set1 & set2
    union => s1 | s2
    symmetric_difference =>

Functions:
    def method_name():
        do. . .
        return value #not mandatory

    Anything written afer return doesnt cause an error but is never executed

    Parameterized:
    def method(a , b):
        return a*b

    Default parameters: => should be at the end of parameter list
    def exponent(num, power = 2): => if nothing specified, default value is used!
        return num ** power

    Passing function as argument:
    def add(a,b, fn=exponent):
        return fn(a,b)

    keyword argument:
    exponent(power = 3, num = 2) => still return 2^3 = 8

    scope:

    total = 0
    def increment():
       total++
       return total
    increment()  #error => cant find it in function scope

    Correct way:
    def increment():
       ðŸ˜ƒglobal total
       total++
       return total

Nested functions and their scope:

    def outer():
        count = 0
        def inner():
            ðŸ˜ƒnonlocal count
            count++
            return count
         return inner()

    Documenting functions:
    def my_func():
        """ function description """
        print("hello")

    ðŸ˜ƒprint(my_func.__doc__) => function description

  ðŸ˜ƒ*args => it converts input into tuple
  def add(a,b,c,d,e)
        print(a-b-c-d-e)

  other way:
  def add(*arg_variable):
    for x in * arg_variable:
        print(x)

  **kwargs => stores remaining arguments in a dictionary
  def add(**kwargs):
    for k,v in kwargs.items():
        print (k + v)

  add('a'=1, 'b'=2, 'c'=3)

  if we pass a whole list/tuple/set in *args, it doesnt unpack them, just converts them into a list
  example:
  a = [1,2,3]
  add(a) => gives error
  Solution: add(*a) => unpacks and sends them as different argument
  Similarly, for dictionaries, pass as method(**dict_variable)


  Parameter ordering:
  1. parameters
  2. *args
  3. default args
  4. **kwargs

  example:
  def display(a,b, *args, name="divya", **kwargs)
    do. . .

  display(1,2,3, last_name = "jain", lang = "python")
  => a =1, b=2
        *args = (3,) => comma will be there after 3 as python distinguishes it from a method call!
        **kwargs = {last_name = "jain", lang = "python"}

